import { Item, WearableCategory } from './item/types'

/**
 * Converts an image blob of a wearable into a fixed 512x512 image encoded as data url.
 * This function also adds some padding according to the category of the wearable.
 *
 * @param blob - The blob of the image.
 * @param category - The category of the wearable.
 */
async function convertImageIntoWearableThumbnail(
  blob: Blob,
  category: WearableCategory = WearableCategory.EYES
) {
  // load blob into image
  const image = new Image()
  const loadFuture = future()
  image.onload = loadFuture.resolve
  image.src = await blobToDataURL(blob)
  await loadFuture

  let padding = 128
  switch (category) {
    case WearableCategory.EYEBROWS:
      padding = 160
      break
    case WearableCategory.MOUTH:
      padding = 160
      break
    case WearableCategory.EYES:
      padding = 128
      break
  }

  // render image into canvas, with a padding from the top. This is to center the textures into the square thumbnail.
  const canvas = document.createElement('canvas')
  canvas.width = 512
  canvas.height = 512
  canvas.style.visibility = 'hidden'
  document.body.appendChild(canvas)
  const ctx = canvas.getContext('2d')!
  ctx.drawImage(image, 0, padding, canvas.width, canvas.height)

  // remove canvas
  document.body.removeChild(canvas)

  // return image
  return canvas.toDataURL()
}

export async function generateImage(item: Item, width = 256, height = 256) {
  // fetch thumbnail

  const response = await fetch(
    getContentsStorageUrl(item.contents[item.thumbnail]),
    { headers: NO_CACHE_HEADERS }
  )
  if (!response.ok)
    throw new Error(`Error generating the image: ${response.statusText}`)

  const thumbnail = await response.blob()

  // create canvas
  const canvas = document.createElement('canvas')
  canvas.width = width
  canvas.height = height
  const context = canvas.getContext('2d')

  // fail
  if (!context || !item.rarity) return thumbnail

  // render gradient
  const gradient = context.createRadialGradient(
    width / 2,
    height / 2,
    0,
    width / 2,
    height / 2,
    width / 1.75
  )
  gradient.addColorStop(0, RARITY_COLOR_LIGHT[item.rarity!])
  gradient.addColorStop(1, RARITY_COLOR[item.rarity!])
  context.fillStyle = gradient
  context.fillRect(0, 0, width, height)

  // render item
  const img = document.createElement('img')
  const url = URL.createObjectURL(thumbnail)
  const load = future()
  img.onload = load.resolve
  img.src = url
  await load // wait for image to load
  URL.revokeObjectURL(url)
  context.drawImage(img, 0, 0, width, height)

  const blob = future<Blob>()
  canvas.toBlob((result) =>
    result
      ? blob.resolve(result)
      : blob.reject(new Error('Error generating image blob'))
  )
  return blob
}
